%{
    #include "shared.h"
    #include "scope.h"
    #include "coins.tab.hpp"
    
    #include <iostream>
    
    #include <cstring>

    #define YYDEBUG 1
    extern int yylex();
    
    extern int yylineno;
    extern char* yytext;
    
    

    int yyerror(char* message);
    
    VarType arithmeticParse(VarType lhs, VarType rhs,enum yytokentype op);
    
    
/*=== Globals API ===*/    

	void dumpScope();
	extern ScopeGlobal* globals;
	void addScope(ScopeType scopeT);
    bool addVar(VarType varType, std::string idName);
    bool varExists(std::string name);
    VarType varType(std::string name);
    bool isScopeCurlyWhile();
    void setCurlyBraces(bool curly);

%}

%nonassoc IF
%nonassoc ELSE

%token LP
%token RP
%token LC
%token RC
%token SC
%token ASSIGN

%token INT
%token NIS
%token AGORA
%token PRINT
%token INPUT
%token<name> ID
%token<name> STRING
%token TRUE
%token FALSE

%token WHILE
%token BREAK
%token BOOL
%token<number> NUM

%right NOT

%left AND OR
%left SE GE EQ NEQ GT ST
%left PLUS MINUS
%left MULT DIV


%type<type> Type
%type<type> CoinType
%type<expInfo> Exp
%type<scopeData> Statement
%type<scopeData> Statements
%type<scopeData> S
%%

S	: Statements {dumpScope();}
	;
Statements	: Statements Statement {}
			| Statement {}
			;
			
Statement	: LC { addScope(CURLY_S); } Statements RC {
									dumpScope();
								}	/* { ... } */
			| Type ID SC {
							if (!addVar($1,$2))
							{
								output::errorDef(yylineno,$2.c_str());
								YYABORT;
							}
								
						 }	   	/* int x; */
						 
			| Type ID ASSIGN Exp SC {
										if (!addVar($1,$2))
										{
											output::errorDef(yylineno,$2.c_str());
											YYABORT;
										}
										if ($4.type != $1)
										{
											output::errorMismatch(yylineno);
											YYABORT;											
										}
										
									} /* int x = a+b; */
			| ID ASSIGN Exp SC {
									if (!varExists($1))
									{
										output::errorUndef(yylineno,$1.c_str());
										YYABORT;
									}
									if ($3.type != varType($1))
									{
										output::errorMismatch(yylineno);
										YYABORT;											
									}			
							   }	   /* x = a+b; */
			| PRINT ID SC {
							if (!varExists($2))
							{
								output::errorUndef(yylineno,$2.c_str());
								YYABORT;															
							}
							if (varType($2) == BOOL_T)
							{
								output::errorMismatch(yylineno);
								YYABORT;								
							}
			
						  }   	   /* print x; */
			| PRINT STRING SC {}	   /* print "bla bla"; */
			| INPUT ID SC {
							if (!varExists($2))
							{
								output::errorUndef(yylineno,$2.c_str());
								YYABORT;															
							}
							if (varType($2) == BOOL_T)
							{
								output::errorMismatch(yylineno);
								YYABORT;								
							}			
						  }  	   /* input x; */
			
			
			| IF ScopeIf LP Exp RP Statement %prec IF {
												if ($4.type != BOOL_T)
												{
													output::errorMismatch(yylineno);
													YYABORT;												
												}
												dumpScope();												
																								
											  }   /* if ( x == 4 ) { ...} */
			| IF ScopeIf LP Exp RP Statement ELSE { addScope(ELSE_S); } Statement %prec ELSE 											  
											 {
												if ($4.type != BOOL_T)
												{
													output::errorMismatch(yylineno);
													YYABORT;												
												}
												
												dumpScope();																										  
											  } 											  
			 /* if ( x == 4 ) { ...} else { ... } */ 
			
			| WHILE {addScope(WHILE_S);} LP Exp RP Statement {
											if ($4.type != BOOL_T)
											{
												output::errorMismatch(yylineno);
												YYABORT;												
											}
											dumpScope();	
										} /* while ( x > 2 ) { ... } */
			| BREAK SC {
							if (!isScopeCurlyWhile())
							{
								output::errorUnexpectedBreak(yylineno);
								YYABORT;
							}
						}  /* break; */
			;
ScopeIf:
	/* empty */ { addScope(IF_S); }
	;		
			
/*=== No Globals needed below this point ===*/			

CoinType	: NIS {$$ = NIS_T;} /* NIS */
			| AGORA {$$ = AGORA_T;} /* AGORA */
			;

Type		: CoinType {$$ = $1;} 	    /* NIS */
		| INT {$$ = INT_T;}   	    /* int */
		| BOOL {$$ = BOOL_T;} 	    /* bool */
		;

Exp		: LP Exp RP {
						$$.type = $2.type;
					} 	    /* ( x < 4 ) */

/* Arithmetic Rules */					
					
		| Exp PLUS Exp {										
							$$.type = arithmeticParse($1.type,$3.type,PLUS);
							if ($$.type == ERROR_T)
								YYABORT;
					   }   /* a + b */
		| Exp MINUS Exp {										
							$$.type = arithmeticParse($1.type,$3.type,MINUS);
							if ($$.type == ERROR_T)
								YYABORT;							
					    }   /* a - b */
		| Exp MULT Exp  {										
							$$.type = arithmeticParse($1.type,$3.type,MULT);
							if ($$.type == ERROR_T)
								YYABORT;							
					    }    /* a * b */
		| Exp DIV Exp   {										
							$$.type = arithmeticParse($1.type,$3.type,DIV);
							if ($$.type == ERROR_T)
								YYABORT;							
					    }     /* a / b */
					    
/* Type rules and var names */					    
					    
		| ID {$$.name = std::string($1);}	      	    /* a */
		| NUM {$$.type = INT_T;}	    /* 4 */
		| NUM CoinType {$$.type = $2;}   /* 4 NIS */
		| TRUE {$$.type = BOOL_T;}	    /* True */
		| FALSE	{ $$.type = BOOL_T;}	    /* False */
		
/* Boolean rules */
		
		| NOT Exp {
						if ($2.type != BOOL_T)
						{
							output::errorMismatch(yylineno);
							YYABORT;
						}
						else
						{
							$$.type = BOOL_T;
						}						
				  }	    /* not (x < 4) */
		| Exp OR Exp {
						if ($1.type != BOOL_T || $3.type != BOOL_T)
						{
							output::errorMismatch(yylineno);
							YYABORT;
						}
						else
						{
							$$.type = BOOL_T;
						}
						
					 }	    /* (x > 4) || (x < 5) */
		| Exp AND Exp {
						if ($1.type != BOOL_T || $3.type != BOOL_T)
						{
							output::errorMismatch(yylineno);
							YYABORT;
						}
						else
						{
							$$.type = BOOL_T;
						}		
					  }    /* (x > 4) && (x < 5) */
		| Exp Rel Exp %prec SE {
									if (($1.type == INT_T && $3.type == INT_T)||
										(($1.type == AGORA_T || $1.type == NIS_T) &&
											($3.type == AGORA_T || $3.type == NIS_T)))
									{
										$$.type = BOOL_T;
									}
									else
									{
										output::errorMismatch(yylineno);
										YYABORT;										
									}
									
							   }    /* x < 4 */
		;

Rel		: GT {} /* > */
		| GE {} /* >= */
		| ST {} /* < */
		| SE {} /* <= */
		| EQ {} /* == */
		| NEQ {} /* != */
		;
%%

int main()
{
	/* Init */
	globals = new ScopeGlobal();
	globals->addScope(MAIN_S);

	
	//yydebug = 1;
		
	yyparse();

	/* Clean-up */
	delete globals;
}

int yyerror(char* message)
{
	if (strcmp(message,"syntax error") == 0)
	{
		output::errorSyn(yylineno);
	}
}

VarType arithmeticParse(VarType lhs, VarType rhs,enum yytokentype op)
{
	if (rhs == BOOL_T || rhs == BOOL_T)
	{
			output::errorMismatch(yylineno);
			return ERROR_T;
	}		
		
	switch(lhs)
	{
		case INT_T:		
			if (rhs == INT_T)
				return lhs;
			if (op == MULT)
				return rhs;
			output::errorMismatch(yylineno);
			return ERROR_T;
			
			break;
		case AGORA_T:
		case NIS_T:
			if (rhs == INT_T)
			{
				if(op == MULT || op == DIV)
					return lhs;
				output::errorMismatch(yylineno);
				return ERROR_T;
			}
			if (rhs == AGORA_T || rhs == NIS_T)
			{
				if (op == DIV)
					return INT_T;
				if (op == MULT)
				{
					output::errorMismatch(yylineno);
					return ERROR_T;				 	
				}
				return lhs;
			}					
			break;	
			
	}
	
	return lhs;

}

/*=== Globals API ===*/

void addScope(ScopeType scopeT)
{
	globals->addScope(scopeT);
}

void dumpScope()
{
	//std::cout << yylineno << std::endl;
	globals->dumpCurrentScope();
}

bool addVar(VarType varType, std::string idName)
{
	return globals->addVarToCurrentScope(varType,idName);	
}

bool varExists(std::string idName)
{
	return globals->varExistsInCurrentScope(idName);
}

VarType varType(std::string idName)
{
	return globals->getCurrentScopeVarType(idName);
}

bool isScopeCurlyWhile()
{
	globals->isCurrentScopeCurlyWhile();
}

void setCurlyBraces(bool curly)
{
	globals->setCurrentScopeCurly(curly);
}
